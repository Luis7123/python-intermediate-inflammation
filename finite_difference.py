# -*- coding: utf-8 -*-
"""finite_difference_methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_huUa4JikMBEbcskfLZGBDvrN-XXVyFW
"""

import numpy as np
import matplotlib.pyplot as plt

"""# Forward Difference Method."""


def heatfd(xl, xr, yb, yt, M, N):
    '''it calculates the finite element method heat forwards

    - doc
    - doc2
    '''
    f = lambda x: np.sin(2 * np.pi * x) ** 2
    l = lambda t: 0 * t
    r = lambda t: 0 * t

    D = 1  # diffusion coefficient

    h = (xr - xl) / M
    k = (yt - yb) / N
    m = M - 1
    n = N

    sigma = D * k / (h * h)
    print(sigma)
    a = np.diag(1 - 2 * sigma * np.ones(m)) + np.diag(sigma * np.ones(m - 1), 1)
    a = a + np.diag(sigma * np.ones(m - 1), -1)
    lside = l(yb + np.arange(n + 1) * k)
    rside = r(yb + np.arange(n + 1) * k)
    w = np.zeros((m, n + 1))
    w[:, 0] = f(xl + np.arange(1, m + 1) * h)

    for j in range(n):
        w[:, j + 1] = np.dot(a, w[:, j]) + sigma * np.concatenate(([lside[j]], np.zeros(m - 2), [rside[j]]))

    w = np.vstack((lside, w, rside))  # attach boundary conds
    x = np.arange(0, m + 2) * h
    t = np.arange(0, n + 1) * k
    X, T = np.meshgrid(x, t)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, T, w.T)
    ax.view_init(20, -30)
    ax.set_xlim([xl, xr])
    ax.set_ylim([yb, yt])
    ax.set_zlim([-1, 1])
    plt.show()
    return w


w = heatfd(0, 1, 0, 1, 10, 250)

"""# Backward Difference Method"""


def heatbd(xl, xr, yb, yt, M, N):

    f = lambda x: np.sin(2 * np.pi * x) ** 2
    l = lambda t: 0 * t
    r = lambda t: 0 * t

    D = 1  # diffusion coefficient

    h = (xr - xl) / M
    k = (yt - yb) / N
    m = M - 1
    n = N

    sigma = D * k / (h * h)
    print(sigma)
    a = np.diag(1 + 2 * sigma * np.ones(m)) + np.diag(-sigma * np.ones(m - 1), 1)
    a = a + np.diag(-sigma * np.ones(m - 1), -1)
    lside = l(yb + np.arange(n + 1) * k)
    rside = r(yb + np.arange(n + 1) * k)
    w = np.zeros((m, n + 1))
    w[:, 0] = f(xl + np.arange(1, m + 1) * h)

    for j in range(n):
        w[:, j + 1] = np.linalg.solve(a, w[:, j] + sigma * np.concatenate(([lside[j]], np.zeros(m - 2), [rside[j]])))

    w = np.vstack((lside, w, rside))  # attach boundary conds
    x = np.arange(0, m + 2) * h
    t = np.arange(0, n + 1) * k
    X, T = np.meshgrid(x, t)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, T, w.T)
    ax.view_init(20, -30)
    ax.set_xlim([xl, xr])
    ax.set_ylim([yb, yt])
    ax.set_zlim([-1, 2])
    plt.show()
    return w


w = heatbd(0, 1, 0, 1, 10, 10)

"""# Crankâ€“Nicholson Method."""


def crank(xl, xr, yb, yt, M, N):
    f = lambda x: np.sin(2 * np.pi * x) ** 2
    l = lambda t: 0 * t
    r = lambda t: 0 * t

    D = 1  # diffusion coefficient

    h = (xr - xl) / M
    k = (yt - yb) / N
    m = M - 1
    n = N

    sigma = D * k / (h * h)
    print(sigma)
    a = np.diag(2 + 2 * sigma * np.ones(m)) + np.diag(-sigma * np.ones(m - 1), 1)
    a = a + np.diag(-sigma * np.ones(m - 1), -1)  # define tridiagonal matrix a
    b = np.diag(2 - 2 * sigma * np.ones(m)) + np.diag(sigma * np.ones(m - 1), 1)
    b = b + np.diag(sigma * np.ones(m - 1), -1)

    lside = l(yb + np.arange(n + 1) * k)
    rside = r(yb + np.arange(n + 1) * k)

    w = np.zeros((m, n + 1))
    w[:, 0] = f(xl + np.arange(1, m + 1) * h)

    for j in range(n):
        sides = np.concatenate(([lside[j] + lside[j + 1]], np.zeros(m - 2), [rside[j] + rside[j + 1]]))
        w[:, j + 1] = np.linalg.solve(a, np.dot(b, w[:, j]) + sigma * sides)

    w = np.vstack((lside, w, rside))  # attach boundary conds
    x = np.arange(0, m + 2) * h
    t = np.arange(0, n + 1) * k
    X, T = np.meshgrid(x, t)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, T, w.T)
    ax.view_init(20, -30)
    ax.set_xlim([xl, xr])
    ax.set_ylim([yb, yt])
    ax.set_zlim([-1, 1])
    plt.show()
    return w


w = crank(0, 1, 0, 1, 10, 10)
w
